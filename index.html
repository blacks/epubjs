<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <title>ePub js test</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <style type="text/css">
      body {
        font-family: georgia;
        line-height: 1.5em;
        background-color: rgb(245,245,245);
      }
      .clear { display: inline-block;
      }   
      .clear:after, .book:after {
        content: "."; 
        display: block; 
        height: 0; 
        clear: both; 
        visibility: hidden;
      }
      * html .clear { height: 1%; }
      .clear { display: block; }
      #book { 
        width: 800px;
        margin:auto;
        border: 1px dotted rgb(210, 210, 210);
        padding: 20px;
        height: 600px;
        overflow:hidden;
        background-color:white;
      }
      a:visited, a:link {
        color: rgb(90,90,90);
        text-decoration:none;
      }
      #toc-container {
        float:left;
        width:150px;
        font-size:x-small;
      }
      #toc {
        list-style-type:none;
        margin:0; 
        padding:1em 1em 10em 1em;
      }
      #content {
        float:right;
        width:600px;      
        padding-right: 1em;
        padding-left: 1em;
        border-left: 2px solid rgb(210,210,210);
      }
      #content-title {
        float:right;
        width:600px;      
      }
      a.selected {
         font-weight: bold;
         color: black;
         text-decoration: none;
      }
      #total-size {
        width: 500px;
        height: 5px;
        margin-left: 200px;
        border: 1px solid rgb(200,200,200);
        clear:right;
      }
      #remaining {
        background-color:rgb(200,200,200);
        height: 5px;
        width:0;
      }
    </style>
    <script src="http://www.google.com/jsapi"></script>
    <script type="text/javascript">
      google.load("jquery", "1.3");
    </script>
  </head>
  <body>
    <script type="text/javascript">
      var page_stack = new Array();
      var epub_dir = 'epub';
      var oebps_dir = '';
      var opf_file = null;
      var ncx_file = null;
      var abs_container_bottom = null;
          
      function process_content() {
         $('#content p').css('color','white');
         
         if (abs_container_bottom == null) {    
            // This won't be accurate until the content is first loaded
            abs_container_bottom = $('#book').height() + $('#book').offset().top;
         }

         var target_height = null;
         var para_offset = null;
         var obscured_para = null;
         var last_unobscured_para = null;

         // Find the paragraph that's below the bounding box
         $('#content p:visible').each(function() {
            var top = parseInt($(this).offset().top);
            para_offset = parseInt(top + $(this).height());
            var line_height = parseInt($(this).css('line-height').replace('px', ''));

            if (para_offset > abs_container_bottom) {
               var top_with_padding = top + (line_height);
               if ( top_with_padding > abs_container_bottom) {
                 // We went too far; this paragraph starts below the fold.
                 // This means the previous paragraph broke acceptably, so just return
                 return false;
               }
               obscured_para = $(this);
               var letter_width = obscured_para.css('font-size').replace('px', '');
               var para_width   = obscured_para.css('width').replace('px', '');
               target_height    = abs_container_bottom - line_height;
               return false;
            }
            last_unobscured_para = $(this);

         });

         // Given a paragraph that needs to be broken, find the minimum displayable
         // text and push the remaining text to a new paragraph.
         // This could be improved by accelerating quickly when the disparity between
         // the current height and target height are great. 
         // Also investigate methods to preserve the DOM integrity of the original
         // by wrapping the overflow into a hidden span rather than by segmenting
         // it into a new paragraph.
         
         if (obscured_para != null && obscured_para.text() != '') {
            text_overflow = new Array();

            while (para_offset > target_height) {
              t = obscured_para.text();
              index = t.length - 1;
              // Jump by word
              while (index > 0 && t.charAt(index) != ' ') {
                 index--;
              }
              text_overflow.push(t.substr(index + 1, t.length - 1));
              obscured_para.text(t.substr(0, index));
              if (index == 0) {
                break;
              }

              para_offset = parseInt(obscured_para.position().top + obscured_para.height());
            }

            // Put the overflow text into a new paragraph after the last one
            obscured_para.after($('<p/>').text(text_overflow.reverse().join(' ')));

            // Hide all the remaining paragraphs
            obscured_para.nextAll('p').hide();

        }
        var status = new Object();
        status.top = $($('#content p:visible')[0]);
        if (obscured_para != null) {
           status.bottom = obscured_para;
        }
        else {
           status.bottom = last_unobscured_para;
           // Are there any more paragraphs?  If so, hide them
           if (last_unobscured_para) {
               last_unobscured_para.nextAll('p').hide();
           }
        }
        page_stack.push(status);
        $('#content p').css('color','black');

        // Now look at what is visible and figure out what page this is
        var num_chars = 0;
        $('#content p:visible').each(function() {
          num_chars += $(this).text().length;
        });
        var num_chars_invisible = 0;
        $('#content p:hidden').each(function() {
          num_chars_invisible += $(this).text().length;
        });
        var num_chars_before = 0;
        status.top.prevAll('p').each(function() {
          num_chars_before += $(this).text().length;
        });

        var invisible = 500 / num_chars_invisible;
        var all = num_chars_invisible + num_chars;
        var percent = num_chars_before / all;
        if (num_chars_invisible == num_chars_before) {
          percent = 1;
        }
        var width = 500 * percent;
        $('#remaining').css('width', width + 'px');
      }

      function fade_content(content) {
        content.attr('class', 'faded');
      }
      
      function load_content() {
        page = $(this).attr('href');
        // Unselect other sections
        $('.selected').attr('class', 'unselected');
        $(this).attr('class', 'selected');
        $('#content').load(page, null, process_content);
        return false;
      }

      function next() {
        top = page_stack[page_stack.length-1].bottom;
        if (top) {
          top.prevAll('p').hide();
          top.hide();
          if (top.nextAll('p').length == 0) {
            return next_chapter();
          }
          top.nextAll('p').show();
        }
        else {
          return next_chapter();
        }
        process_content();
      }
      function previous() {
        // If we have no pages to go back to, call the previous chapter function instead.
        // This isn't really what the reader probably means -- they want to turn
        // back to the previous _page_ before the beginning of that chapter,
        // but we could only potentially do that if we had visited the page already
        // and had it in the stack.
        
        var status = page_stack.pop();
        if (status.top.prev('p').length == 0) {
          return previous_chapter();
        }
        status.top.hide();
        status = page_stack.pop();
        status.bottom.hide();
        status.top.show();
        status.top.nextAll('p:hidden').show();
        process_content();
      }

      function next_chapter() {
        // Simulate a click event on the next chapter after the selected one
        $('a.selected').parent().next('li').find('a').click();

        // How far is the selected chapter now from the bottom border?
        var selected_position = $('a.selected').position().top;
        var height_of_toc = $('a.selected').height();

        if (selected_position - (height_of_toc * 2) > abs_container_bottom / 2) {
          // Hide the first visible chapter item
          $('#toc a:visible:eq(0)').hide();
        }
        $('#remaining').css('width', '0px');
      }

      function previous_chapter() {
        // Simulate a click event on the next chapter after the selected one
        $('a.selected').parent().prev('li').find('a').click();

        // Have we hidden any chapters that we now want to show?
        $('#toc a:visible:eq(0)').parent().prev('li').find('a').show();

        $('#remaining').css('width', '0px');
      }


      /* Open the container file to find the resources */
      function container(f) {
        opf_file = $(f).find('rootfile').attr('full-path');               
        // Get the OEPBS dir, if there is one
        if (opf_file.indexOf('/') != -1) {
            oebps_dir = opf_file.substr(0, opf_file.lastIndexOf('/'));
        }
        opf_file = epub_dir + '/' + opf_file;
      }
      
      /* Open the TOC, get the first item and open it */
      function toc(f) {

         $(f).find('navPoint').each(function() { 
            var s = $('<span/>').text($(this).find('text').text());
            var a = $('<a/>').attr('href', $(this).find('content').attr('src'));
            s.appendTo(a);
            a.appendTo($('<li/>').appendTo('#toc'));
         });

         // Click on the desired first item link 
         $('#toc a:eq(1)').click();
      }
      /* Open the OPF file and read some useful metadata from it */
      function opf(f) {
         // Get the document title
         $('#content-title').html($(f).find('dc\\:title').text() + ' by ' +  $(f).find('dc\\:creator').text());

         // Get the NCX
         $(f).find('opf\\:item').each(function() {
           // Cheat and find the first file ending in NCX
           if ( $(this).attr('href').indexOf('.ncx') != -1) {
             ncx_file = epub_dir + '/' + oebps_dir + $(this).attr('href');
             return;
           }
         });
         
      }
      jQuery(document).ready(function() {
         jQuery.get(epub_dir + '/META-INF/container.xml', {}, container);
//         jQuery.get(opf_file, {}, opf);
//         jQuery.get(toc_file, {}, toc);
         jQuery.get('content.opf', {}, opf);
         jQuery.get('toc.ncx', {}, toc);


         $('#toc a').live('click', load_content);
         $(document).bind('keydown', function(e) {
           var code = (e.keyCode ? e.keyCode : e.which);
           if (code == 39 || code == 78 ) {  // right or 'n'
             next();
           }
           if (code == 37 || code == 80) {  // left or 'p'
             previous();
           }
           if (code == 40 || code == 74) { // down  or 'j'
             next_chapter();
           }
           if (code == 38 || code == 75 ) { // up or 'k'
             previous_chapter();
           }
         });
        }
      );
    </script>
    <div id="book" class="clear">
      <div id="toc-container"><ol id="toc"></ol></div>
      <h1 id="content-title" ></h1>
      <div id="total-size"><div id="remaining"></div></div>
      <div id="content"></div>
    </div>
    <p style="margin:auto;font-size:smaller;text-align:center;color:gray">Usage: 'right-arrow' for next page, 'left-arrow' for previous page, 'down-arrow' for next chapter, 'up-arrow' for previous chapter</p>
    <p style="margin:auto;font-size:smaller;text-align:center;color:gray">Current support: Firefox, Safari. As of February 17, 2009</p> 
  </body>
</html>